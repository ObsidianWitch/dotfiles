#!/usr/bin/env python3

import sys
import os
import argparse

class Table(dict):
    def __init__(self, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self.__dict__ = self

    def __iter__(self): return iter(self.values())

class Xattr:
    @classmethod
    def list(cls, path): return [
        attr[5:] for attr in os.listxattr(path)
    ]

    @classmethod
    def dict(cls, path): return dict(cls.iter(path))

    @classmethod
    def iter(cls, path):
        for attr in cls.list(path):
            yield attr, cls.get(path, attr)

    @classmethod
    def rm(cls, path, attr):
        try: os.removexattr(path, "user." + attr)
        except OSError: print(f"Xattr.rm: {path} does not contain {attr}")

    @classmethod
    def get(cls, path, attr): return os.getxattr(
        path, "user." + attr
    ).decode()

    @classmethod
    def set(cls, path, attr, val): os.setxattr(
        path, "user." + attr, val.encode()
    )

class Tag:
    def __init__(self):
        parser = argparse.ArgumentParser(
            description = "Tagging tool using extended attributes (xattr)."
        )
        parser.add_argument("-d", "--debug",
            action = "store_true",
            help   = "display traceback"
        )
        subparsers = parser.add_subparsers(
            required = True,
            dest     = "command",
            metavar  = "command",
            help     = "{ls, search, add, rm, clean}",
        )

        # ls
        parser_ls = subparsers.add_parser("ls",
            help = "List tags for the given files.",
        )
        parser_ls.add_argument("-s", "--shared", action = "store_true")
        parser_ls.add_argument("paths", nargs = "*", default = [ "." ])

        # search
        parser_search = subparsers.add_parser("search",
            help     = "Search files by evaluating the given expression.",
            add_help = False,
        )
        parser_search.add_argument("expression")
        parser_search.add_argument("directory", nargs = "?", default = ".")

        # add
        parser_add = subparsers.add_parser("add",
            help = "Add tag to the given files.",
        )
        parser_add.add_argument("-v", "--value",
            default = "",
            type    = self.str_nocolon,
        )
        parser_add.add_argument("tag", type = self.str_nocolon)
        parser_add.add_argument("paths", nargs = "+")

        # rm
        parser_rm = subparsers.add_parser("rm",
            help = "Remove tag from the given files.",
        )
        parser_rm.add_argument("tag")
        parser_rm.add_argument("paths", nargs = "+")

        # clean
        parser_clean = subparsers.add_parser("clean",
            help = "Remove all tags from the given files.",
        )
        parser_clean.add_argument("paths", nargs = "+")

        # parse
        args = parser.parse_args()
        if not args.debug: sys.tracebacklimit = 0
        getattr(self, args.command)(args)

    @staticmethod
    def str_nocolon(value):
        if ":" in value: sys.exit(
            f"error: string '{value}' cannot contain colons"
        )
        return value

    @classmethod
    def ls(cls, args):
        def iterator():
            for path in args.paths:
                if not os.path.isdir(path): yield path ; continue
                dirpath, dirnames, filenames = next(os.walk(path))
                filenames.sort()
                yield dirpath
                yield from ( os.path.join(dirpath, d) for d in dirnames )
                yield from ( os.path.join(dirpath, f) for f in filenames )

        def default():
            for path in iterator():
                xattrs = Xattr.dict(path)
                if not xattrs: continue
                strxattrs = str(xattrs) \
                          .replace("'", "").replace(": ", ":") \
                          .replace("{", "{ ").replace("}", " }")
                print(f"{path}: {strxattrs}")

        def shared():
            result = {}
            for path in iterator():
                for attr, value in Xattr.iter(path):
                    if attr not in result:
                        result[attr] = Table(vals = set(), count = 0)
                    result[attr].vals.add(value)
                    result[attr].count += 1

            for tag, (vals, count) in result.items(): print(
                f"{tag}"
                f":{min(vals) if len(vals) <= 1 else 'â‰ '}"
                f":{count}"
            )

        if args.shared: shared()
        else: default()

    @classmethod
    def search(cls, args):
        def walk(directory):
            for dirpath, _, filenames in os.walk(directory):
                filenames.sort()
                yield dirpath
                yield from ( os.path.join(dirpath, f) for f in filenames )

        def satisfy_one(attrs, criterion):
            include = (criterion in attrs)
            exclude = (criterion[0] == "~") and (criterion[1:] not in attrs)
            return include or exclude

        def satisfy_all(filepath):
            criteria = args.expression.split()
            attrs = Xattr.list(filepath)
            return all(
                satisfy_one(attrs, criterion)
                for criterion in criteria
            )

        print(*filter(
            lambda filepath: satisfy_all(filepath),
            walk(args.directory)
        ))

    @classmethod
    def add(cls, args):
        for path in args.paths: Xattr.set(
            path, args.tag, args.value
        )

    @classmethod
    def rm(cls, args):
        for path in args.paths: Xattr.rm(
            path, args.tag
        )

    @classmethod
    def clean(cls, args):
        for path in args.paths:
            for tag in Xattr.list(path):
                Xattr.rm(path, tag)

Tag()
